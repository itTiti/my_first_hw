import pprint as pp
'''
Задача №1
Создайте словарь, содержащий имена и возрасты нескольких людей. Затем напишите программу,
которая печатает все имена людей, возраст которых больше или равен 18.
'''

# names = 'olesya', 'jolie', 'vlad', 'danila'
# ages = [22, 18, 2, 33]

# user_info = list(zip(names, ages)) ### У нас здесь список ? Потому что если применить методы словаря - ошибку выдаёт
# print(type(user_info)) ### <class 'list'> !!!!! список с взаимосвязанной инфой ????
# print(user_info)

# ### Вариант № 1
# for key in user_info:
#     if key[1] >= 18:
#         print(key[0])
#
# #print('*' * 50)
#
# ### Вариант №2
# for key in user_info:
#     new_users = [key[0] for key in user_info if key[1] >= 18]
# print(new_users)
#
# print('~' * 50)
#
# users_info = dict(zip(names, ages))
# print(type(users_info)) #### <class 'dict'>
# print(users_info)
# #
# users_over_eighteen = []
# for name, age in users_info.items():
#     if age >= 18:
#         users_over_eighteen.append(name)
# print(users_over_eighteen)


# ### через генератор
# for name, age in users_info.items():
#     users_over_eighteen = [name for name, age in users_info.items() if age >= 18] ### Что я не так делаю? Почему в список попадат все имена?
# print(users_over_eighteen)



# users_over_eighteen = [age for age in users_info.values() if age >= 18] ### Что я не так делаю? Почему в список попадат все имена?
# print(users_over_eighteen)

'''
Задача №2
Напишите программу, которая запрашивает у пользователя строку и затем выводит количество каждой буквы в этой строке в алфавитном порядке. 
Используйте словарь для хранения количества каждой буквы.
'''
#stroka = input('> ')
#print(type(stroka))
#stroka_new = stroka.lower().split() ### Приводим объект к единому формату хранения данных.
#print(type(stroka_new))
#join_stroka_new = ' '.join(stroka_new) ## почему join отменяет формат stroka_new ? там список был, теперь просто строка.
#stroka_new_2 = list(stroka) ### Можно, по идее, просто передать строку в лист и все символы будут отдельными.
### Если я начинаю работать с переменной stroka_new, то в словаре у меня будет ключ это одно слово, а значение =1
### Если я работаю в цикле с простой строкой stroka, то считаются все символы, включая пробелы.





# stroka = input('> ')
# stroka_new = stroka.lower().split()
# ### Тобишь, мне нужно разделить все символы. Чтобы посчитать каждый символ в for, а не каждое слово. Например, через Join()
# stroka_new = ' '.join(stroka).lower().split() ### При этом, если join присоединить вместе с остальными методами, то остаётся тип данных лист.
# stroka_new = [x for x in stroka_new if x.strip('.,!?')] ### Генерируем список из каждого символа (join)
#                                                                 ### Также исключаем из списка знаки препинания и пробелы.
#                             ### Не получается корректно применить join в генераторе, чтоб дополнительную переменную не создавать.
# print(stroka_new)
#
# dict_1 = dict() ### Сохраняем в списке неповторяющиеся символы(ключи), суммируя количество повторения каждого элемента, и храня их в зачениях
# for x in stroka_new:
#     if x not in dict_1:
#         dict_1[x] = 1
#     else:
#         dict_1[x] += 1
# print(dict_1)
# 
# uniq = sorted(list(dict_1.items()))
# for x, y in uniq:
#     print(f'{x}= {y}, ', end='')
'''
Задача №3
Создайте словарь, который содержит названия городов и их население.
Напишите программу, которая запрашивает у пользователя название города и выводит его население.
Если город не найден в словаре, программа должна вывести сообщение об ошибке.
'''
# cityes = 'москва', 'воронеж', 'новосибирск'
# population = [13_097_539, 1_047_000, 1625]
#
# dict_cityes = dict(zip(cityes, population))

# name_of_the_city = input('Введите название города и я сообщу вам население этого города> ').lower()

### Первое о чём я подумала - цикл for. Чтобы пробежаться по словарю и найти этот город и его население, так ничего и не вышло.
### задача только усложнилась.
### Почему я всегда пытаюсь присобачить этот for? и всегда ли он нужен?

# if name_of_the_city not in dict_cityes:
#     answ = 'Такого города нет в нашей базе.'
# else:
#     answ = f'Население города {name_of_the_city.title()}, {dict_cityes[name_of_the_city]}'
# print(answ)

'''
Задача №4
Напишите программу, которая запрашивает у пользователя строку и затем выводит все уникальные слова в этой строке в алфавитном порядке.
Используйте словарь для хранения количества каждого слова.
'''
### Схожа со второй задачей. Пока оставила. Скорее всего здесь используется метод  set()

# str = input('> ')
# str_new = str.lower().split() ### строка 113 и 116 хранят один и тот же тип данных, в одинаковом виде. Зачем тогда ещё раз создавать?
#                               ### Чтобы не трогать основную переменную, которая хранит единый формат данных???
#
# str_new = [x.strip(',!:?') for x in str_new] ### strip() Удаляет пробельные символы в начале и конце слова и те, что указаны в параметре?
#                     ### Обходим в генераторе списка, чтобы иметь возможность к каждому элементу(который строка), применить метод strip ???
#
#
# result = dict()
# for x in str_new:
#     if x not in result:
#         result.setdefault(x, 1)
#     else:
#         result[x] += 1
# pp.pprint(result, width=15)
# uniq = sorted(list(result.keys())) ### Но почему они уникальны? потому что в цикле for мы не добавляли одинаковые символы?
# for x in uniq:
#     print(x, end=' ')



# ls = ['z', 'tebya', 'tebya', 'z', 'k', 'a']
# sorted_ls = sorted(set(ls))
# print(sorted_ls)

'''
Задача №5
Создайте словарь, который содержит цену на каждый продукт в вашем магазине.
Напишите программу, которая запрашивает у пользователя название продукта и выводит его цену. 
Если продукт не найден в словаре, программа должна вывести сообщение об ошибке.
'''

### Задача схожа с задачей №3, решила попробовать метод через get - Получилось компактнее.

# products = ['яблоки', 'груши', 'мандарины', 'ананас']
# prices = 22, 15, 89, 32
#
# products_prices = dict(zip(products, prices))
# prod = input('Какой товар хотите приобрести?> ').lower()
# print('Стоимость продукта: ',products_prices.get(prod, 'Товар отсутствует!'))


